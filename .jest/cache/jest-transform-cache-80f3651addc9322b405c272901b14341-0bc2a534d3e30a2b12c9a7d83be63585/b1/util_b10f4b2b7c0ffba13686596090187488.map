{"version":3,"names":["_Colors","require","_NativeReanimated","_interopRequireDefault","_matrixUtils","IN_STYLE_UPDATER","initialUpdaterRun","updater","result","recognizePrefixSuffix","value","_match$","match","Error","prefix","suffix","number","strippedValue","parseFloat","applyProgressToMatrix","progress","a","b","addMatrices","scaleMatrix","subtractMatrices","applyProgressToNumber","decorateAnimation","animation","isHigherOrder","baseOnStart","onStart","baseOnFrame","onFrame","animationCopy","Object","assign","callback","prefNumberSuffOnStart","timestamp","previousAnimation","_animation$__prefix","_animation$__suffix","_recognizePrefixSuffi","__prefix","__suffix","strippedCurrent","_recognizePrefixSuffi2","toValue","strippedToValue","current","startValue","_recognizePrefixSuffi3","paPrefix","paSuffix","paStrippedValue","_previousAnimation$__","_previousAnimation$__2","prefNumberSuffOnFrame","_animation$__prefix2","_animation$__suffix2","res","tab","colorOnStart","RGBAValue","RGBACurrent","RGBAToValue","isColor","toLinearSpace","convertToRGBA","forEach","i","index","undefined","push","rgbaArrayToRGBAColor","toGammaSpace","colorOnFrame","finished","transformationMatrixOnStart","startMatrices","decomposeMatrixIntoMatricesAndAngles","stopMatrices","transformationMatrixOnFrame","transforms","mappedTransforms","key","_","currentTranslation","currentScale","skewMatrix","rotations","mappedRotations","angle","getRotationMatrix","rotationMatrixX","rotationMatrixY","rotationMatrixZ","rotationMatrix","multiplyMatrices","updated","flatten","arrayOnStart","v","arrayOnFrame","objectOnStart","objectOnFrame","newObject","isAffineMatrixFlat","Array","isArray","IS_NATIVE","NativeReanimatedModule","native","defineAnimation","starting","factory","create","_WORKLET","cancelAnimation","sharedValue","withStartValue"],"sources":["util.ts"],"sourcesContent":["import type {\n  HigherOrderAnimation,\n  NextAnimation,\n  StyleLayoutAnimation,\n} from './commonTypes';\nimport type { ParsedColorArray } from '../Colors';\nimport {\n  isColor,\n  convertToRGBA,\n  rgbaArrayToRGBAColor,\n  toGammaSpace,\n  toLinearSpace,\n} from '../Colors';\n\nimport type {\n  AnimatedStyle,\n  SharedValue,\n  AnimatableValue,\n  Animation,\n  AnimationObject,\n  Timestamp,\n  AnimatableValueObject,\n} from '../commonTypes';\nimport NativeReanimatedModule from '../NativeReanimated';\nimport {\n  AffineMatrixFlat,\n  AffineMatrix,\n  flatten,\n  multiplyMatrices,\n  scaleMatrix,\n  addMatrices,\n  decomposeMatrixIntoMatricesAndAngles,\n  isAffineMatrixFlat,\n  subtractMatrices,\n  getRotationMatrix,\n} from './transformationMatrix/matrixUtils';\n\nlet IN_STYLE_UPDATER = false;\n\nexport type UserUpdater = () => AnimatedStyle;\n\nexport function initialUpdaterRun<T>(updater: () => T): T {\n  IN_STYLE_UPDATER = true;\n  const result = updater();\n  IN_STYLE_UPDATER = false;\n  return result;\n}\n\ninterface RecognizedPrefixSuffix {\n  prefix?: string;\n  suffix?: string;\n  strippedValue: number;\n}\n\nfunction recognizePrefixSuffix(value: string | number): RecognizedPrefixSuffix {\n  'worklet';\n  if (typeof value === 'string') {\n    const match = value.match(\n      /([A-Za-z]*)(-?\\d*\\.?\\d*)([eE][-+]?[0-9]+)?([A-Za-z%]*)/\n    );\n    if (!match) {\n      throw Error(\n        \"Couldn't parse animation value. Check if there isn't any typo.\"\n      );\n    }\n    const prefix = match[1];\n    const suffix = match[4];\n    // number with scientific notation\n    const number = match[2] + (match[3] ?? '');\n    return { prefix, suffix, strippedValue: parseFloat(number) };\n  } else {\n    return { strippedValue: value };\n  }\n}\n\nfunction applyProgressToMatrix(\n  progress: number,\n  a: AffineMatrix,\n  b: AffineMatrix\n) {\n  'worklet';\n  return addMatrices(a, scaleMatrix(subtractMatrices(b, a), progress));\n}\n\nfunction applyProgressToNumber(progress: number, a: number, b: number) {\n  'worklet';\n  return a + progress * (b - a);\n}\n\nfunction decorateAnimation<T extends AnimationObject | StyleLayoutAnimation>(\n  animation: T\n): void {\n  'worklet';\n  if ((animation as HigherOrderAnimation).isHigherOrder) {\n    return;\n  }\n\n  const baseOnStart = (animation as Animation<AnimationObject>).onStart;\n  const baseOnFrame = (animation as Animation<AnimationObject>).onFrame;\n  const animationCopy = Object.assign({}, animation);\n  delete animationCopy.callback;\n\n  const prefNumberSuffOnStart = (\n    animation: Animation<AnimationObject>,\n    value: string | number,\n    timestamp: number,\n    previousAnimation: Animation<AnimationObject>\n  ) => {\n    // recognize prefix, suffix, and updates stripped value on animation start\n    const { prefix, suffix, strippedValue } = recognizePrefixSuffix(value);\n    animation.__prefix = prefix;\n    animation.__suffix = suffix;\n    animation.strippedCurrent = strippedValue;\n    const { strippedValue: strippedToValue } = recognizePrefixSuffix(\n      animation.toValue as string | number\n    );\n    animation.current = strippedValue;\n    animation.startValue = strippedValue;\n    animation.toValue = strippedToValue;\n    if (previousAnimation && previousAnimation !== animation) {\n      const {\n        prefix: paPrefix,\n        suffix: paSuffix,\n        strippedValue: paStrippedValue,\n      } = recognizePrefixSuffix(previousAnimation.current as string | number);\n      previousAnimation.current = paStrippedValue;\n      previousAnimation.__prefix = paPrefix;\n      previousAnimation.__suffix = paSuffix;\n    }\n\n    baseOnStart(animation, strippedValue, timestamp, previousAnimation);\n\n    animation.current =\n      (animation.__prefix ?? '') +\n      animation.current +\n      (animation.__suffix ?? '');\n\n    if (previousAnimation && previousAnimation !== animation) {\n      previousAnimation.current =\n        (previousAnimation.__prefix ?? '') +\n        previousAnimation.current +\n        (previousAnimation.__suffix ?? '');\n    }\n  };\n  const prefNumberSuffOnFrame = (\n    animation: Animation<AnimationObject>,\n    timestamp: number\n  ) => {\n    animation.current = animation.strippedCurrent;\n    const res = baseOnFrame(animation, timestamp);\n    animation.strippedCurrent = animation.current;\n    animation.current =\n      (animation.__prefix ?? '') +\n      animation.current +\n      (animation.__suffix ?? '');\n    return res;\n  };\n\n  const tab = ['R', 'G', 'B', 'A'];\n  const colorOnStart = (\n    animation: Animation<AnimationObject>,\n    value: string | number,\n    timestamp: Timestamp,\n    previousAnimation: Animation<AnimationObject>\n  ): void => {\n    let RGBAValue: ParsedColorArray;\n    let RGBACurrent: ParsedColorArray;\n    let RGBAToValue: ParsedColorArray;\n    const res: Array<number> = [];\n    if (isColor(value)) {\n      RGBACurrent = toLinearSpace(convertToRGBA(animation.current));\n      RGBAValue = toLinearSpace(convertToRGBA(value));\n      if (animation.toValue) {\n        RGBAToValue = toLinearSpace(convertToRGBA(animation.toValue));\n      }\n    }\n    tab.forEach((i, index) => {\n      animation[i] = Object.assign({}, animationCopy);\n      animation[i].current = RGBACurrent[index];\n      animation[i].toValue = RGBAToValue ? RGBAToValue[index] : undefined;\n      animation[i].onStart(\n        animation[i],\n        RGBAValue[index],\n        timestamp,\n        previousAnimation ? previousAnimation[i] : undefined\n      );\n      res.push(animation[i].current);\n    });\n\n    animation.current = rgbaArrayToRGBAColor(\n      toGammaSpace(res as ParsedColorArray)\n    );\n  };\n\n  const colorOnFrame = (\n    animation: Animation<AnimationObject>,\n    timestamp: Timestamp\n  ): boolean => {\n    const RGBACurrent = toLinearSpace(convertToRGBA(animation.current));\n    const res: Array<number> = [];\n    let finished = true;\n    tab.forEach((i, index) => {\n      animation[i].current = RGBACurrent[index];\n      const result = animation[i].onFrame(animation[i], timestamp);\n      // We really need to assign this value to result, instead of passing it directly - otherwise once \"finished\" is false, onFrame won't be called\n      finished &&= result;\n      res.push(animation[i].current);\n    });\n\n    animation.current = rgbaArrayToRGBAColor(\n      toGammaSpace(res as ParsedColorArray)\n    );\n    return finished;\n  };\n\n  const transformationMatrixOnStart = (\n    animation: Animation<AnimationObject>,\n    value: AffineMatrixFlat,\n    timestamp: Timestamp,\n    previousAnimation: Animation<AnimationObject>\n  ): void => {\n    const toValue = animation.toValue as AffineMatrixFlat;\n\n    animation.startMatrices = decomposeMatrixIntoMatricesAndAngles(value);\n    animation.stopMatrices = decomposeMatrixIntoMatricesAndAngles(toValue);\n\n    // We create an animation copy to animate single value between 0 and 100\n    // We set limits from 0 to 100 (instead of 0-1) to make spring look good\n    // with default thresholds.\n\n    animation[0] = Object.assign({}, animationCopy);\n    animation[0].current = 0;\n    animation[0].toValue = 100;\n    animation[0].onStart(\n      animation[0],\n      0,\n      timestamp,\n      previousAnimation ? previousAnimation[0] : undefined\n    );\n\n    animation.current = value;\n  };\n\n  const transformationMatrixOnFrame = (\n    animation: Animation<AnimationObject>,\n    timestamp: Timestamp\n  ): boolean => {\n    let finished = true;\n    const result = animation[0].onFrame(animation[0], timestamp);\n    // We really need to assign this value to result, instead of passing it directly - otherwise once \"finished\" is false, onFrame won't be called\n    finished &&= result;\n\n    const progress = animation[0].current / 100;\n\n    const transforms = ['translationMatrix', 'scaleMatrix', 'skewMatrix'];\n    const mappedTransforms: Array<AffineMatrix> = [];\n\n    transforms.forEach((key, _) =>\n      mappedTransforms.push(\n        applyProgressToMatrix(\n          progress,\n          animation.startMatrices[key],\n          animation.stopMatrices[key]\n        )\n      )\n    );\n\n    const [currentTranslation, currentScale, skewMatrix] = mappedTransforms;\n\n    const rotations: Array<'x' | 'y' | 'z'> = ['x', 'y', 'z'];\n    const mappedRotations: Array<AffineMatrix> = [];\n\n    rotations.forEach((key, _) => {\n      const angle = applyProgressToNumber(\n        progress,\n        animation.startMatrices['r' + key],\n        animation.stopMatrices['r' + key]\n      );\n      mappedRotations.push(getRotationMatrix(angle, key));\n    });\n\n    const [rotationMatrixX, rotationMatrixY, rotationMatrixZ] = mappedRotations;\n\n    const rotationMatrix = multiplyMatrices(\n      rotationMatrixX,\n      multiplyMatrices(rotationMatrixY, rotationMatrixZ)\n    );\n\n    const updated = flatten(\n      multiplyMatrices(\n        multiplyMatrices(\n          currentScale,\n          multiplyMatrices(skewMatrix, rotationMatrix)\n        ),\n        currentTranslation\n      )\n    );\n\n    animation.current = updated;\n\n    return finished;\n  };\n\n  const arrayOnStart = (\n    animation: Animation<AnimationObject>,\n    value: Array<number>,\n    timestamp: Timestamp,\n    previousAnimation: Animation<AnimationObject>\n  ): void => {\n    value.forEach((v, i) => {\n      animation[i] = Object.assign({}, animationCopy);\n      animation[i].current = v;\n      animation[i].toValue = (animation.toValue as Array<number>)[i];\n      animation[i].onStart(\n        animation[i],\n        v,\n        timestamp,\n        previousAnimation ? previousAnimation[i] : undefined\n      );\n    });\n\n    animation.current = value;\n  };\n\n  const arrayOnFrame = (\n    animation: Animation<AnimationObject>,\n    timestamp: Timestamp\n  ): boolean => {\n    let finished = true;\n    (animation.current as Array<number>).forEach((_, i) => {\n      const result = animation[i].onFrame(animation[i], timestamp);\n      // We really need to assign this value to result, instead of passing it directly - otherwise once \"finished\" is false, onFrame won't be called\n      finished &&= result;\n      (animation.current as Array<number>)[i] = animation[i].current;\n    });\n\n    return finished;\n  };\n\n  const objectOnStart = (\n    animation: Animation<AnimationObject>,\n    value: AnimatableValueObject,\n    timestamp: Timestamp,\n    previousAnimation: Animation<AnimationObject>\n  ): void => {\n    for (const key in value) {\n      animation[key] = Object.assign({}, animationCopy);\n      animation[key].onStart = animation.onStart;\n\n      animation[key].current = value[key];\n      animation[key].toValue = (animation.toValue as AnimatableValueObject)[\n        key\n      ];\n      animation[key].onStart(\n        animation[key],\n        value[key],\n        timestamp,\n        previousAnimation ? previousAnimation[key] : undefined\n      );\n    }\n    animation.current = value;\n  };\n\n  const objectOnFrame = (\n    animation: Animation<AnimationObject>,\n    timestamp: Timestamp\n  ): boolean => {\n    let finished = true;\n    const newObject: AnimatableValueObject = {};\n    for (const key in animation.current as AnimatableValueObject) {\n      const result = animation[key].onFrame(animation[key], timestamp);\n      // We really need to assign this value to result, instead of passing it directly - otherwise once \"finished\" is false, onFrame won't be called\n      finished &&= result;\n      newObject[key] = animation[key].current;\n    }\n    animation.current = newObject;\n    return finished;\n  };\n\n  animation.onStart = (\n    animation: Animation<AnimationObject>,\n    value: number,\n    timestamp: Timestamp,\n    previousAnimation: Animation<AnimationObject>\n  ) => {\n    if (isColor(value)) {\n      colorOnStart(animation, value, timestamp, previousAnimation);\n      animation.onFrame = colorOnFrame;\n      return;\n    } else if (isAffineMatrixFlat(value)) {\n      transformationMatrixOnStart(\n        animation,\n        value,\n        timestamp,\n        previousAnimation\n      );\n      animation.onFrame = transformationMatrixOnFrame;\n      return;\n    } else if (Array.isArray(value)) {\n      arrayOnStart(animation, value, timestamp, previousAnimation);\n      animation.onFrame = arrayOnFrame;\n      return;\n    } else if (typeof value === 'string') {\n      prefNumberSuffOnStart(animation, value, timestamp, previousAnimation);\n      animation.onFrame = prefNumberSuffOnFrame;\n      return;\n    } else if (typeof value === 'object' && value !== null) {\n      objectOnStart(animation, value, timestamp, previousAnimation);\n      animation.onFrame = objectOnFrame;\n      return;\n    }\n    baseOnStart(animation, value, timestamp, previousAnimation);\n  };\n}\n\ntype AnimationToDecoration<\n  T extends AnimationObject | StyleLayoutAnimation,\n  U extends AnimationObject | StyleLayoutAnimation\n> = T extends StyleLayoutAnimation\n  ? Record<string, unknown>\n  : U | (() => U) | AnimatableValue;\n\nconst IS_NATIVE = NativeReanimatedModule.native;\n\nexport function defineAnimation<\n  T extends AnimationObject | StyleLayoutAnimation, // type that's supposed to be returned\n  U extends AnimationObject | StyleLayoutAnimation = T // type that's received\n>(starting: AnimationToDecoration<T, U>, factory: () => T): T {\n  'worklet';\n  if (IN_STYLE_UPDATER) {\n    return starting as unknown as T;\n  }\n  const create = () => {\n    'worklet';\n    const animation = factory();\n    decorateAnimation<U>(animation as unknown as U);\n    return animation;\n  };\n\n  if (_WORKLET || !IS_NATIVE) {\n    return create();\n  }\n  // @ts-ignore: eslint-disable-line\n  return create;\n}\n\nexport function cancelAnimation<T>(sharedValue: SharedValue<T>): void {\n  'worklet';\n  // setting the current value cancels the animation if one is currently running\n  sharedValue.value = sharedValue.value; // eslint-disable-line no-self-assign\n}\n\n// TODO it should work only if there was no animation before.\nexport function withStartValue(\n  startValue: AnimatableValue,\n  animation: NextAnimation<AnimationObject>\n): Animation<AnimationObject> {\n  'worklet';\n  return defineAnimation(startValue, () => {\n    'worklet';\n    if (!_WORKLET && typeof animation === 'function') {\n      animation = animation();\n    }\n    (animation as Animation<AnimationObject>).current = startValue;\n    return animation as Animation<AnimationObject>;\n  });\n}\n"],"mappings":"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"}